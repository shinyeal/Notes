# 数据结构

- 数据结构 = 结构定义 + 结构操作

```
整型和指针类型都属于数据结构
区别：整型可以做乘除法，指针类型不可以
```



[TOC]

-----------



## 顺序表与链表



### 顺序表

顺序表：可以表示为**一类特殊的数组**

```
1.结构定义：有一片连续的存储区，可以存储任意类型的元素
2.额外字段： 标记顺序表大小：
		   标记顺序表元素：
		   每个格子存储的元素类型：存储顺序表也可以
3.插入：插入位置后面元素平行向后移动一位
4.删除：删除位置后面元素平行向前移动一位
```



### 链表

#### 单向链表

```
1.结构定义：对于一个链表单元的结构定义，元素内部有两个字段，其中一个存储的是任意元素的数据区，第二个字段存储的是指向链表元素的下一个元素的地址
2.链表其实是存储在内存中的，程序中使用链表的变量是一个指针
  程序内部：head指针变量，指针丢失的话就会失去他的链表
  内存内部：存储链表
3.插入：找到插入位置的前一个节点(p指向它)，新插入节点(node指向它)指向他的后一个节点，p指向node。（插入是有顺序的）
4.删除：让删除节点的前一个节点指向他后一个节点， 再删除当前节点
```



#### 单向循环链表

```
把head看做整个单向循环链表的尾节点， 头指针存储的是尾部节点的地址，尾部节点发生改变以后更新head里面存储的值。
```



## 栈和队列

### 队列

- 结构定义：有一片连续的存储空间用来存放连续的若干个元素
  - 对头指针，队尾指针，队列长度，队列中元素的结构类型。
- 结构操作：
  - 入队：队尾指针后移动一位，相关元素放到队尾所指向位置，数据区和队尾指针改变
  - 出队：可以认为是一种**逻辑操作**，队头指向第一个元素时，队首指针向后移动一位，在逻辑上将第一个元素出队
- 性质：先进先出
- 假溢出：队尾指针加一，溢出，但队首还有空间

#### 循环队列

- 解决假溢出问题，将队尾指针加一发现溢出了，就重新将队尾指针指向队首

- tail指针和head指针与队列长度的关系

  - 入队：tail指针与队列长度相等并且队列中的元素个数小于队列长度

    ```c
    if(q->tail + 1 >= q->length) q->tail -= q->length;
    ```

  - 出队：head指针与队列长度相等并且队列不为空时

    ```c
    if(q->head + 1 >= q->length) q->head -= q->length;
    ```

  - 输出：从队首元素开始，对队列长度取模，即为待插入元素的位置

    ```c
    for(int i = 0; i <= q->tail; i++) {
        int ind = (q->head + i) % q->length;
        printf(" %d", q->data[ind]);
        i + 1 == q->cnt || printf(",");
    }
    ```

    

####　单调队列

- 单调队列有单调递增和单调递减两种，一般来讲，队列的队首是整个队列的最大值或最小值，单调队列可以解决许多问题，而且可以用来优化DP
- 具体步骤
  - 若队列为空，将A[i]从队尾入队
  - 若队列不为空，将比A[i]大的元素都从队尾弹出，然后把A[i]入队
  - 若队列不为空且A[i]大于队尾，则直接从队尾把A[i]入队
- 单调队列可以解决的问题：
  - 可以求出一个数组内第一个大于等于一个数x的数
  - 可以通过维护单调性，解决一些区间内最小或最大的问题

### 栈

- 从哪一头进就从哪一头出
- 结构定义：栈有一片连续的数据区域，数据区放一片连续的任意类型的元素
  - 栈顶指针只指向一个元素，栈的大小
- 结构操作：
  - 入栈：从栈顶指针的上一个位置入栈，栈顶指针向上移动一位，把新的元素放进来，改变top指针和数据区
  - 出栈：从栈顶指针当前位置出栈，栈顶指针向下移动一位，当top这个指针等于 - 1 时代表栈空了
- 性质：后进先出

#### 单调栈

。。。。。。。。。。。。。。。。。。。



#### [*] 括号匹配问题（leetcode 20）

用到了栈的思想（以前还不了解，现在一看突然就懂了），括号匹配问题如果可以匹配成功只有两种可能

- 第一种：在任意一个位置上，左括号数量 >= 右括号
- 在最后一个位置上，左括号数量 == 右括号



二叉排序树：用到了递归

```
节点：集合     节点的边：关系
根节点：全集    他的几个分支：互不相交的子集
```

一组树形结构可以被看成一个括号序列， 一个括号序列可以看成一组函数执行流程

#### 用栈实现队列

用两个栈：

![](/home/xinyue/Markdown/1. 数据结构/picture/20180527092623978.jpg)



#### 队列实现栈

。。。。。。。。。。。。。。。。

## 树与二叉树



### 树

线性结构：一一映射的（链表：当前节点只能映射到一个节点）

树形结构：一对多的映射

```
树形结构的性质：
1.节点：集合    2.边：关系
对于链表的结构体而言， 树形结构就是在链表的基础上增加后继节点的指针数量
链表（一叉树）是特殊的树形结构
```



#### 树的深度高度和度

```
1.树的深度和高度相同，节点的深度和高度和当前节点所在子树相关
2.节点的深度：从根节点走到相关节点的路径长度
  节点的高度：从当前节点作为子树的根节点，走到当前节点子树的叶子节点处（最深处）的深度差
3.度：当前节点的孩子节点数量
4.节点数量 = 边数 + 1
5.在二叉树中， 度为2的节点比度为0的节点少一个
n = n0 + n1 + n2   
(n:节点总数， n0:度为0的节点数量， n1:度为1的节点的数量，n2:度为2的节点数量)
0 * n0 + 1 * n1 + 2 * n2 + 1 = n0 + n1 + n2
（边数 + 1） = （点数）
所以：  n2 + 1 = n0
```



### 二叉树

#### 二叉树遍历

```
前序遍历：根左右
中序遍历：左根右
后序遍历：左右根
```



**完全二叉树**：最后一层只缺少右侧的节点

```
1.编号是i的子节点, 他的节点的左子树编号是2 * i，右子树编号是(2 * i) + 1;
2.可以用连续空间存储（数组）
好处：不需要存储子节点的地址，只记录数据信息就行，可以节省大量的空间(一个指针域占8个字节当存储数据很大的时候能节省的字节十分可观)
```

引申出一种优化方式：**记录式(记忆式)改计算式**   (可以节省大量的空间，可能影响时间效率)

**满二叉树(完美二叉树)**：除了度为0就是度为2（**哈弗曼树**）



##### 二叉树广义表

```
（ ）可以等价为：
1.进栈和出栈的顺序  2.或者是一种树形结构  3.事件之间的包含关系
```



**两点之间的最短路径**：deep[a] + deep[b] - 2 * deep[c]

**最近公共祖先**：1.深度相同：就是一起往上走

​			   2.深度不同：走到相同深度再一起往上走	

**B树**：所有叶子节点处在同一层

二叉排序树：左子树小与根节点，右子树大于根节点

树转二叉树：左孩子，右兄弟

**线索二叉树（中序遍历）**

- 是以链表的访问形式，也可以倒序遍历(右改成左，左改成右)

- 他的本质上是**双向链表**

```
步骤：
1.如果当前节点有左子树， 一直往左走
2.输出当前节点的key值
3.如果当前节点有右孩子，往右走一步，返回步骤1.
4.如果没有右孩子，沿着右边的线索(后继)走，返回步骤2.
```



## 堆与优先队列

### 堆

- 本质上是一棵**完全二叉树**
  - 完全二叉树的性质：父节点和子节点地址之间是通过计算得到的（这种方式可以节省存储空间）
  - 编号为i的子节点：左孩子编号：`2 × i`   ，父节点编号：`2 × i + 1`   
  - 完全二叉树可以用连续的空间存储（数组）
- 数据结构是分成两个层面的：一个是实现在程序里的，一个是思维逻辑结构
  - 完全二叉树就是体现在这两个思维结构上的
- 堆的性质：任意的三元组，如果根节点都大于等于两个子节点，满足这种性质的堆叫做大顶堆，否则：如果根节点小于等于两个子节点的堆叫做小顶堆
- 想要维护全局最小值就用小顶堆，想要维护全局最大值就用大顶堆

#### 插入元素（入堆）

- 堆的插入元素从来都是从堆尾操作
- 插入节点和它的父节点比较大小，如果不符合当前堆的性质就和父节点的元素进行交换，知道满足为止



#### 删除元素（出堆）

- 堆的删除从来是从堆顶弹出
- 把数组最后一个元素放到头部，然后根据堆的性质从上到下调整堆



#### 扩展问题

- 有一个无序数组,每个元素排序后,相对位置一定和当前位置不超过10,问如何排序?
  - 建立一个10个元素的小顶堆, 对于第一个最小的数,一定在前10个元素中,弹出后加入第11个元素;第二个最小的元素,一定在前11个元素中,弹出后加入第12个元素;第三个最小的数,一定在前12个数中,...........
- 有一亿个数的数组，要找最小的10个数
  - 建立一个10个元素的大顶堆,每次来新数就和堆顶元素比较,若小于堆顶元素,则弹出堆顶,此数留下.
  - 则所有数比较完后即找到了最小的10个数
  - 同理,要找最大的10个数时,则建立维护一个小顶堆
- 求解区间内5个连续的数（区间内数字无重复）
  - 单调队列,本质:维护区间最值(滑动窗口内部的最值),区间也可以为变长区间
    - 比如递减的单调队列,维护区间的最大值
    - 入队时,从后往前挤,把小于它的都挤出去
    - 出队时,  ... 
    - 对于每个元素,都入队和出队一次,因此均摊时间复杂度为2n,由于维护两个单调队列,则时间复杂度为O(4n)



### 优先队列

- 堆与优先队列本质上是一种数据结构
- 堆的入堆从尾部入，出堆时从头部出，这种性质和队列的性质一样
- 堆可以维护全局最大 (小) 值



- 在操作系统中，有很多进程，进程是有不同的进程优先级的，操作系统怎么能知道现在应该运行哪个程序？

  ```
  最优的最先执行，（怎样能快速找到最优的呢？）A:它的每个进程都存放到任务队列里，每次从任务队列中取出优先级最大的元素进行处理
  ```

  - 普通队列无法满足这种需求，但是堆可以满足这种需求，由堆衍生出来的这种队列的概念就叫做优先队列

- 优先队列外在表现和队列是一样的，只是内部维护了一种优先级而已

- 同样是一维数组，以线性关系关系来看他就是一个线性表，但是以堆（完全二叉树）的这种形式来看数组时就会得到一个完全不一样的操作

- 堆的本质上更多的是思维逻辑结构，底层存储结构就是一个数组



## 排序与查找



### 排序 

根据排序过程中元素是否完全保存在内存中，可以将算法分为 **内部排序** 和 **外部排序**。

#### 稳定排序（不会改变相同元素的下标位置）

- 有两个数值大小相等的元素，如果在排完序之后他们的相对位置不变，具有这一类性质的排序就是稳定排序，否则就是非稳定排序

**插入排序：**n^2  

已排序区在前面，待排序区在后面，待排序区指向已排序区

- 每次从待排序区的头部选择一个元素向已排序区进行插入
- 插入排序的第一轮不用排，第二轮平均交换概率是1/2，第n轮概率是(n - 1) / 2

**冒泡排序：**n^2

已排序区在后边，待排序区在前边

- 每次从待排序区第一个元素开始向后进行比较，每次如果当前元素要大于后边的元素则两者交换，然后指针向后移动一位，一直当指针移动到待排序区的最后一位，冒泡排序将待排序区的最大值冒到了待排序区的最后一个位置，形成了新的已排序区的一个头部元素，每轮通过冒泡让已排序区增加一个元素。
- 优化方式：如果冒泡排序在某轮排序之后没有进行交换操作，我们就停止操作

- 逆序数：整个数组中违反数字顺序的对数
  - 冒泡：每做一次操作减少一个逆数对，交换次数等于逆序数的数对个树
- n^2量级（？？？）

**归并排序：**nlogn

将大规模的数据拆分为多个小规模

- 将一个大数组拆分成两个小数组，然后一直拆分， 知道拆分成小规模再合并，最后拷贝回原来的数组中。
- 他的时间复杂度是稳定在nlogn的，冒泡排序如果原数组有序一遍就可以结束（O(n) ），原数组逆序（O(n ^ 2)），插入排序有序（O(n)），原数组逆序（O(n ^ 2)）
- 排序的时间复杂度和排序的状况有关联。
- 每一层元素数量和原数组相等，最重要的操作是他的合并操作，归并排序的每一层至少都做了O(n)次操作，归并排序的层数是log2(n) （二叉树树高），总操作数是n次，所以时间复杂度稳定在nlogn。



**各个排序的时间复杂度：**

```
1：简单选择  最好时间 O(n^2)      平均时间O(n^2)      最坏时间 O(n^2)

2：直接插入  最好时间 O(n)         平均时间O(n^2)      最坏时间 O(n^2)

3：冒泡排序  最好时间 O(n)         平均时间O(n^2)      最坏时间 O(n^2)

4：希尔排序  最好时间 O(n)         平均时间O(logn)     最坏时间 O(n^s) 1<s<2

5：快速排序  最好时间 O(nlogn)  平均时间O(nlogn)   最坏时间O(n^2) 

6：堆排序      最好时间 O(nlogn)  平均时间O(nlogn)   最坏时间O(nlogn) 

7：归并排序  最好时间 O(nlogn)  平均时间O(nlogn)   最坏时间O(nlogn) 
```



#### 不稳定排序

**选择排序：** n ^ 2

已排序区在前面，待排序区在后面，待排序区指向他待排序区的末尾

- 每次从待排序区选择一个最小的数放在当前排序区的位置(也就是已排序区的末尾)
- 选择排序次都要遍历待排序区的每一个元素
- 时间复杂度稳定在n ^ 2
- 选择排序为什么是非稳定排序呢？
  - 举一个例子：`5 7 6 5 2 8`
  - 在寻找第一个最小的数字时5和2交换，两个5的先后顺序自然就改变了

**快速排序：**

- 选择基数：将原来的快速排序的数组分为两段，前半段小与等于基准值，后半段大于等于基准值
- 怎样进行一轮快排：
  - 作为第一个元素作为基准值，我们就可以认为第一个位置是空的，所以我们头尾两个指针尾部指针先往前找，找到一个违反规则的值，就是他要比基准值小但是他在后半段，然后头尾指针值互换，这时尾指针所指向位置变为基准值，头指针往后找元素。。
- 他是一个递归过程（还有非递归版本，）

#### 相关博客

[稳定排序和不稳定排序的意义与分析](https://blog.csdn.net/yangnianjinxin/article/details/77918882)

### 二分查找与三分查找



### [*]信息熵

```
1.信息熵：表示系统的混乱程度(状态)，状态数越多越混乱（种类多熵越大）
2.一个二进制位表示两种信息
eg：数据挖掘，机器学习，决策树
3.熵的大小和排列顺序有关，一个有序的数组比一个无序的数组的熵要小，熵越大越难解决
4.排序：前提依赖小，可以减小问题的系统熵，当减小到一定程度，就变成一个可解决的问题
5.越高级的算法需要的前提条件越多
6.排序算法需要的前提依赖最小
```



#### 二分查找：

在一个有序的数组中查找一个元素x是否存在

- 核心点：不断的缩小待查找区间的长度

本质是在做单调函数的求解问题

##### 两种特殊情况：

![](/home/xinyue/Markdown/1. 数据结构/picture/2018-11-07 21-16-59屏幕截图.png)

- 如果数组中全都是0(要查找的是1)，要返回 -1，所以在头部增加一个虚拟节点



![](/home/xinyue/Markdown/1. 数据结构/picture/2018-11-07 21-28-23屏幕截图.png)

##### **错误更改！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！**

```
如果arr[mid] != 1, min = mid + 1
如果arr[mid] == 1, max = mid
如果min == max, 找到结果
```

- 如果数组中全都是0(要查找的是1)，要返回 -1，所以在尾部增加一个虚拟节点处理他的非法情况



#### 三分查找

求解凹凸函数极值求解问题

![](/home/xinyue/Markdown/1. 数据结构/picture/2018-11-07 21-45-47屏幕截图.png)

- 三分查找每一轮的待查找区间缩小 1 / 3
- 查找规则：无论是三分查找还是二分查找，必须保证更新完的区间里还会存在带求解的答案，为了不要错过凸函数的极值的待查找点，一定要找一个较小值更新
- 凹函数反之



二分查找和三分查找：

- 二分每次区间缩小1/2，三分查找每次待查找区间缩小1/3，所以二分查找更快一些
- 二分查找和三分查找 区分的是他们每一次缩小的**问题求解规模**



### 哈希表

哈希表：是用于查找的一类数据结构

**没有固定形状和写法**

- 数组是数组下标到值的一个映射，将一个任意数值类型的元素转成一个整型的映射，可以运用到数组的性质，可以做到时间复杂度是O(1).
- 哈希表有一片连续的存储区，这片存储区就是所谓的数组
- 哈希函数的作用：将一个任意类型的元素转成一个数字

#### 冲突处理：

处理待插入元素位置存在其他元素

四种方法：（开放定值法（常用）， 拉链法（常用）， 再哈希法（写多个哈希函数处理冲突），建立公共溢出区）

### 【×】

```
哈希：高维空间到低维空间的一个映射
高维空间：状态数多的空间（计算机可能存不下），低维空间： 状态数少的空间
MD5 
```



### 字符串匹配

#### 暴力匹配 & KMP匹配

##### 暴力算法引申思考

- 模式串自我匹配，找到相同的字符段。

- n位字符从第n位匹配失配，跳动的字节数位数和匹配成功的字节数相加一定等于`n - 1`
- 母串和模式串失配时，模式串要找到一个新的位置和母串当前位置匹配

![](/home/xinyue/Markdown/1. 数据结构/picture/深度截图_选择区域_20181230154652.png)

##### KMP优化方法！！！！！！！！！！！！



#### SUNDAY算法

- 核心：在模式串中记录每一种字符最后出现的位置
- 相关字符在倒数第几位，母串的指针跳多少位

- N ：母串长度，M：模式串长度

- 最优时间复杂度：N / M
- i + len  最后一次在模式串中出现的位置（i：母串指针位置，len：模式串长度）
- 适合用于一篇文章中某个单词是否出现过
- 如果黄金对齐点失配了直接跳过模式串长度个字符



#### SHIFT-AND 算法

- 时间复杂度：O(n)
- 模式串在整理成
- 长度不超过30的时候时间复杂度就是O(n)，大于30 



单调栈：维护元素最近的值右边或左边第一个比他大或者比他小的值

有一个木板墙怎么切出最大的矩形，枚举每一块木板的高度



### 字典树

- 树的节点代表集合，树的边代表关系
- 字典树上的字母是标记在边上的
- 想用字典树对数字进行排序需要在前缀补齐
- 红色节点：此集合中有以此前缀为单词的词
- 字典树对于具有n个单词的组成的一个数据集合的排序 时间复杂度为O(n)，n代表这些单词的总数量



### 双数组字典树

//////////////太懒，暂时没跟



### AC自动机

- ac自动机是基于字典树的，比字典树多一条fail边，可以看作是一个文本串多个模式串匹配
- AC自动机在匹配时文本串是没有回溯的，可以把AC自动机看成一个小型电脑，所有的连接都完成了，进来一个输入进入下一个状态
  - ac自动机可以流式处理，比如：文本串有40TB，想要找到文本串有多少个单词，就可以用ac自动机处理，不管文本串多大，每次只需要一个字符，然后跳转到下一个状态，这种就适合流失计算，不用考虑前面计算过的状态
  - kmp也是这样
- fail失败指针建立也可以理解为等价匹配指针（匹配成功我也就等于匹配成功你），遗传失败指针连过来证明这一串指针等价
  - 建立一个AC自动机，首先要建立字典树，再在字典树上建立失败指针，建立失败指针是逐层建立的（第二层失败指针最好建立），想要这样逐层的去建立失败指针遍历树中的所有节点就可以用到队列，队列做的是树的层序遍历的，栈做的是树的深度遍历，想要算一个树的树高就用递归写，先算子节点，然后一直往下去，结果再返回到本层节点处理结果

```c
 
/*************************************************************************
   > File Name: 15.Double_Array_Trie.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 六  8/ 4 15:28:36 2018
 ************************************************************************/

//基于双数组字典树的 AC 自动机
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define BASE 26
#define BEGIN_LETTER 'a'
#define max(a, b) ((a) > (b) ? (a) : (b))
#define has_child(data, ind, i) (abs(data[data[ind].base + i].check) == ind)

typedef struct DANode {
    int base, check, fail;
    char *str;
} DANode;

typedef struct Node {
    int flag;
    char *str;
    struct Node *next[BASE];
} Node, *Trie;

int node_cnt = 0;

Node *get_new_node() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    node_cnt += 1;
    return p;
}

void clear(Trie root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    if (root->flag) free(root->str);
    free(root);
    return ;
}

Node *insert(Trie root, const char *str) {
    if (root == NULL) root = get_new_node();
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = get_new_node();
        p = p->next[ind];
    }
    p->flag = 1;
    p->str = strdup(str);
    return root;
}

int get_base(Node *node, DANode *data) {
    int base = 2, flag = 0;
    while (!flag) {
        flag = 1;
        for (int i = 0; i < BASE; i++) {
            if (node->next[i] == NULL) continue;
            if (data[base + i].check == 0) continue;
            flag = 0;
            break;
        }
        base += (!flag);
    }
    return base;
}

int build(Node *node, DANode *data, int ind) {
    if (node == NULL) return 0;
    if (node->flag) data[ind].check = -data[ind].check, data[ind].str = node->str;
    int max_ind = ind;
    data[ind].base = get_base(node, data);
    for (int i = 0; i < BASE; i++) {
        if (node->next[i] == NULL) continue;
        data[data[ind].base + i].check = ind;
    }
    for (int i = 0; i < BASE; i++) {
        if (node->next[i] == NULL) continue;
        int temp = build(node->next[i], data, data[ind].base + i);
        max_ind = max(max_ind, temp);
    }
    return max_ind;
}

void build_ac(DANode *data) {
    #define MAX_N 100000
    int *queue = (int *)malloc(sizeof(int) * MAX_N);
    int head = 0, tail = 0;
    data[1].fail = 0;
    queue[tail++] = 1;
    while (head < tail) {
        int ind = queue[head++];
        for (int i = 0; i < BASE; i++) {
            if (!has_child(data, ind, i)) continue;
            int p = data[ind].fail;
            while (p && !has_child(data, p, i)) p = data[p].fail;
            if (p == 0) p = 1;
            else p = data[p].base + i;
            data[data[ind].base + i].fail = p;
            queue[tail++] = data[ind].base + i;
        }
    }
    return ;
    #undef MAX_N
}

void search_ac(DANode *data, const char *str) {
    int p = 1;
    for (int i = 0; str[i]; i++) {
        while (p && !has_child(data, p, str[i] - BEGIN_LETTER)) p = data[p].fail;
        if (p == 0) p = 1;
        else p = data[p].base + str[i] - BEGIN_LETTER;
        int q = p;
        while (q) {
            if (data[q].check < 0) printf("find string : %s\n", data[q].str);
            q = data[q].fail;
        }
    }
    return ;  
}

void output_da(DANode *data, int n) {
    for (int i = 1; i <= n; i++) {
        if (i - 1 && i % 5 == 1) printf("\n");
        printf("(%2d %2d %3d)    ", i, data[i].base, data[i].check);
    }
    printf("\n");
    return ;
}

int main() {
    Trie root = NULL;
    #define INSERT_CNT 5
    root = insert(root, "hai");
    root = insert(root, "zei");
    root = insert(root, "ha");
    root = insert(root, "ab");
    root = insert(root, "ehz");
    DANode *data = (DANode *)calloc(sizeof(DANode), (INSERT_CNT * 100));
    int da_cnt = build(root, data, 1);
    build_ac(data);
    output_da(data, da_cnt);
    search_ac(data, "sasherhs");
    #undef INSERT_CNT 
    return 0;
}
```



### 森林与并查集

并查集所解决的本质性问题是**连通性判断的问题**

并查集所解决的问题是**没有方向**的

面对连通性问题时基本有两个操作：

- 给一个已知的连通性关系，需要改变已知的连通性关系
- 查询操作，一边给连通性关系，一边查询，查询某两个点是否是联通的

##### Quick Find算法

- 就是将两个联通的点变成相同的颜色，如果是联通两个集合，就需要扫描集合中所有的点并改变他们的颜色
- 联通判断：O(1)，只需要判断颜色
- 合并操作：O(n)，把两个点联通时我们需要把集合中的点全部遍历一遍，去把其中某个颜色值都改成另外一个值
- 问题：
  - quick find 算法联通判断非常快，但是合并操作非常慢
  - 本质上问题中只是需要知道一个点与哪些点的颜色相同
  - 而若干点的颜色可以通过间接指向同一个节点
  - 合并操作时，实际上是将一棵树作为另一棵树的子树

##### Quick Union 算法

- 在进行两个集合的合并是做的是将两个集合的代表元素，也就是根节点进行合并，只需要一步操作

- 联通判断最重要找到树的根节点，也就是树的树高
- 合并操作虽然只有一次，但是要找到根节点也要走一遍它的树高，所以它的合并操作也是他的树高
- 问题:
  - 在极端的情况下这个树会退化成一条链，这时它的联通判断和合并操作都会退化为O(n)，这时它的效率还不如quick find 算法
  - 将节点数量多的接到少的树上面，将树高深的接到浅的上面，导致了退化

##### Quick Onion 优化

- 优化：就是谁的树高就让谁当合并之后的根节点，可以缩短一个数的高度
- 思考：在两个集合进行合并的时候到底是按照树高来合并还是根据节点的数量进行合并？
  - 让节点数量较少的成为子树而不是高度较少的成为子树

##### Weighted Quick Union 算法

- 联通判断：log(N)
- 合并操作：log(N)
- 问题最终优化：
  - 参考quick find算法，做路径压缩
  - 路径压缩：在递归过程的回溯过程的时候将所有节点的父节点改成根节点
    - 联通判断：接近O(1)
    - 合并操作：接近O(1)



### 平衡二叉排序树

#### 二叉排序树

- 名称：二叉排序树，二叉搜索树，二叉查找树

- 性质：左子树 < 根节点， 右子树 > 根节点
- 用途：解决与排名相关的检索需求

数据结构的本质是结构定义+结构操作，结构操作的本质是维护相关数据结构的性质

树型数据结构是定义一种性质并如何维护这种性质

##### 插入：

- 每插入一个新的节点，他都会成为某一个叶子节点

##### 删除

- 删除叶子节点：直接删
- 删除出度为1的节点：待删除节点父节点继承待删除节点的子节点
- 删除出度为2的节点：找到前驱或者后继替换后转换度为1的节点问题

> 快速排序和二叉排序树有什么联系？

- 我们将二叉树排序树按照中序遍历的方式将这个树的访问顺序列出来，就得到了一个有序的数列，根节点的所有左子树都小于根节点，根节点的所有右子树都大于根节点，根节点就像快速排序的基准值，所以快速排序的本质的思维模型就是二叉排序树。



```
STL
map的底层实现是平衡二叉排序树
unordermap 的底层是哈希
```

#### AVL 树

- 排序二叉树有可能会退化成一条链表，它的平均查找时间就会退化成O(n)，相当于遍历

- 使用树形结构就是想加快它的查找时间

- 平衡二叉排序树的目的就是防止排序二叉树退化成链表

- AVL树性质：任意两棵子树的高度差不超过1

  ```
  H(left) - H(right) <= 1
  ```

- 通过控制子数的高度差控制平衡

SB 树是通过节点数量来控制平衡

AVL树是通过树高来控制平衡的



### 红黑树 ( 非常非常重要 )

AVL 树比较严格，调整次数多，代价大

红黑树调整次数少，改颜色就行

红黑树有虚拟叶子节点，虚拟叶子节点是黑色的

- 本质也是通过树高调整平衡

#### 五个条件

1. 每个节点非黑即红
2. 根节点是黑色
3. 叶节点（NIL虚拟叶节点）是黑色
4. 如果一个节点是红色，则它的两个子节点都是黑色的（第二重要）
   - 一个红色节点下必须接两个黑的节点
5. 从根节点出发到所有叶节点路径上，黑色节点数量相同（最重要）
   - 最长路径长度（红-黑-红-黑-红-黑 ...）是最短路径（黑-黑-黑-黑-黑-黑 ...）的两倍

#### 调整策略

1. 插入调整站在**祖父节点**看
2. 删除调整站在**父节点**看
   - 新插入的节点是红色的
   - 失衡（两个红色节点连在一起）
3. 插入和删除的情况处理一共五种



#### 插入调整的情况

（相关红黑树笔记）

#### 删除调整的情况

（相关红黑树笔记）

----------



学渣的假期纠错笔记

队列：

- 判断队列为空不是`q->tail == -1  `  ，而是当队列的头指针大于尾指针时`q->head > q->tail `，表示队列为空	
- 查看队列的对首元素时也需要先判断队列是否为空
- 先查看队首元素再出队，（不然输出结果就乱了啊）